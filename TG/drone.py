import copy
from math import sqrt 
import pygame 

from utils     import limit, constrain, derivativeBivariate
from constants import *

class Drone():
    def __init__(self, x, y, index):
        """
            Idealized class representing a drone
            :param x and y: represents inicial position 
        """
        # Variables used to move drone 
        self.location = pygame.math.Vector2(x,y) 
        self.velocity = pygame.math.Vector2(0,0) 
        self.acceleration = pygame.math.Vector2(0,0)
        self.target = SCREEN_WIDTH
        self.desired = pygame.math.Vector2()
        self.reached = False
        self.alive = True

        # Variables related to State Machine
        self.theta = 0 # variavel para o eight somada no seek_around
        self.count = 0
        self.id = index
        self.name = "Drone " + str(index)
        self.time_executing = 0  

        # State variables
        self.neighbors = pygame.math.Vector2()
        self.obstacles = pygame.math.Vector2()
        self.vulnerability = 0
        self.connectivity = 0


    def reached_goal(self):
        self.reached = self.target - self.location[0] <= THRESHOLD_TARGET
        return self.reached


    def applyForce(self, force):
        self.acceleration += force/MASS 


    def execute(self, action, obstacles, enable_target=True):
        """
            Execute action
            Suffer effects from the environment
        """
        self.time_executing += 1
        # updates behavior in machine state
        if enable_target: 
            self.arrive(self.target)
        # Updates velocity at every step and limits it to max_speed
        self.velocity += self.acceleration 
        # Check if valid action
        next_position = constrain(self.location + self.velocity + action, UPPER_X, UPPER_Y)
        for obs in obstacles:
            if (next_position - obs).magnitude() < AVOID_DISTANCE:
                action = pygame.math.Vector2(0,0)                
        self.velocity += action
        # Limit velocity
        self.velocity = limit(self.velocity, FORWARD_SPEED)
        # Updates position
        self.location += self.velocity 
        # Constrains position to limits of screen 
        self.location = constrain(self.location, UPPER_X, UPPER_Y)
        self.acceleration *= 0
        # Print if drone reached destination
        #if not self.reached and self.reached_goal():
        #    print(f"{self.name} reached target")


    def arrive(self, target):
        """
            Arrive Steering Behavior
        """
        # Calculates vector desired 
        v = pygame.math.Vector2([target - self.location[0], 0])
        # get the distance to the target
        distance = v.magnitude() 
        direction = pygame.math.Vector2(1,0)
        
        # Modulates the force
        if distance < THRESHOLD_TARGET : 
            # close to target it will reduce velocty till stops
            direction *= FORWARD_SPEED*(1 + 1/THRESHOLD_TARGET*(distance-THRESHOLD_TARGET))
        else:
            direction *= FORWARD_SPEED

        # Steering force
        steer = direction - self.velocity
        # Limit the magnitude of the steering force.
        steer = limit(steer, SEEK_FORCE)
        # Apply force to the Drone
        self.applyForce(steer)


    def scan_neighbors(self, positions):
        """
         This method scans for neighbors CM and gets it's direction
         During training it receives all the positions from all drones 
         During evaluation it receives only the positions inside observable area 
        """
        # Calculate potential generated by topology while removing the current drone
        v = pygame.math.Vector2(0,0) 
        for position in positions:
            distance = (position - self.location).magnitude()
            if 0 < distance: # < OBSERVABLE_RADIUS:
                # Get normalized direction of neighbor 
                direction = (position - self.location).normalize() 
                # Proporcional to the distance. The closer the stronger needs to be
                direction = direction / distance 
                v += direction

        # This gives the direction of the resulting potential 
        self.neighbors = v.copy()
                  

    def scan_obstacles(self, positions):
        """
         This method scans for obstacles CM and gets it's direction
         During training it receives all the positions from all obstacles 
         During evaluation it receives only the positions inside observable area 
        """
        # Calculate potential generated by obstacles
        v = pygame.math.Vector2(0,0) 
        for position in positions:
            distance = (position - self.location).magnitude()
            if 0 < distance: # < OBSERVABLE_RADIUS:
                # Get normalized direction of neighbor 
                direction = (position - self.location).normalize() 
                # Proporcional to the distance. The closer the stronger needs to be
                direction = direction / distance 
                v += direction

        # This gives the direction of the resulting potential 
        self.obstacles = v.copy()


    def calculate_potential_field(self, pos_drones, pos_obstacles):
        """
            Determine resulting potential field given obstacles and other drones
        """
        alpha = beta = 0.005
        # Repulsion drones
        for position in pos_drones:
            distance = (self.location - position).magnitude()
            if 0 < distance < OBSERVABLE_RADIUS:
                # Proporcional to the distance. The closer the stronger needs to be
                f_repulsion = (position - self.location).normalize() / sqrt(distance) 
                #f_repulsion = derivativeBivariate(alpha, beta, position, self.location) / SAMPLE_TIME
                #f_repulsion = limit(f_repulsion, SEEK_FORCE)
                self.applyForce(-f_repulsion)

        # --- Repulsion obstacles 
        for position in pos_obstacles:
            distance = (self.location - position).magnitude()
            if 0 < distance < OBSERVABLE_RADIUS:
                # Proporcional to the distance. The closer the stronger needs to be
                f_repulsion = (position - self.location).normalize() / sqrt(distance)
                #f_repulsion = derivativeBivariate(alpha, beta, position, self.location) / SAMPLE_TIME
                #f_repulsion = limit(f_repulsion, SEEK_FORCE)
                self.applyForce(-f_repulsion)

            # Avoids that the drone goes over the obstacle
            if (distance < AVOID_DISTANCE):
                self.velocity *= -1


    def get_state(self):
        return [
            self.location[0] / UPPER_X,
            self.location[1] / UPPER_Y,
            self.vulnerability,
            self.connectivity,
            self.obstacles[0],
            self.obstacles[1],
            self.neighbors[0],
            self.neighbors[1]
        ]
            

    def draw(self, window):
        """
            Defines shape of Drone and draw it to screen
        """
        # usar sprite para desenhar drone
        pygame.draw.circle(window, BLUE, RATIO * self.location, radius=SIZE_DRONE, width=20)

